> https://www.cnblogs.com/ysocean/p/9080942.html
# 基本数据结构
Redis有五种基本数据结构：字符串、hash、list、set、zset。
## String——字符串
## Hash——字典
## List——列表
## Set——集合
## Sorted Set——有序集合

# 底层数据结构
Redis有六种底层数据结构：SDS，链表，map，跳跃表，整数集合，压缩列表

## 简单动态字符串 SDS simple dynamic string
redis中所有场景中出现的字符串，基本都是由SDS来实现的
```
struct sdshdr{
    // 记录 buf 数组中已使用字节的数量 等于 SDS 保存字符串的长度
    int len;
    // 记录 buf 数组中未使用字节的数量
    int free;
    // 字节数组，用于保存字符串
    char buf[];
}
```

## 链表-双向
```
typedef  struct listNode{
    // 前置节点
    struct listNode *prev;
    // 后置节点
    struct listNode *next;
    // 节点的值
    void *value;  
}listNode
typedef struct list{
    // 表头节点
    listNode *head;
    // 表尾节点
    listNode *tail;
    // 链表所包含的节点数量
    unsigned long len;
    // 节点值复制函数
    void (*free) (void *ptr);
    // 节点值释放函数
    void (*free) (void *ptr);
    // 节点值对比函数
    int (*match) (void *ptr,void *key);
}list;
```

Redis链表特性：
1. 双端：链表具有前置节点和后置节点的引用，获取这两个节点时间复杂度都为O(1)。
2. 无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL,对链表的访问都是以 NULL 结束。
3. 带链表长度计数器：通过 len 属性获取链表长度的时间复杂度为 O(1)。
4. 多态：链表节点使用 void* 指针来保存节点值，可以保存各种不同类型的值。

## 字典-map
```
typedef struct dictht{
     // 哈希表数组
     dictEntry **table;
     // 哈希表大小
     unsigned long size;
     // 哈希表大小掩码，用于计算索引值，总是等于 size-1
     unsigned long sizemask;
     // 该哈希表已有节点的数量
     unsigned long used;
}dictht
typedef struct dictEntry{
     // 键
     void *key;
     // 值
     union{
          void *val;
          uint64_tu64;
          int64_ts64;
     }v;
     // 指向下一个哈希表节点，形成链表
     struct dictEntry *next;
}dictEntry
```
## 跳跃表 skiplist
跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其它节点的指针，从而达到快速访问节点的目的。具有如下性质：
1. 由很多层结构组成；
2. 每一层都是一个有序的链表，排列顺序为由高层到底层，都至少包含两个链表节点，分别是前面的head节点和后面的nil节点；
3. 最底层的链表包含了所有的元素；
4. 如果一个元素出现在某一层的链表中，那么在该层之下的链表也全都会出现（上一层的元素是当前层的元素的子集）；
5. 链表中的每个节点都包含两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点；

## 整数集合 intset
整数集合（intset）是Redis用于保存整数值的集合抽象数据类型，它可以保存类型为int16_t、int32_t 或者int64_t 的整数值，并且保证集合中不会出现重复元素。
```
typedef struct intset{
     // 编码方式
     uint32_t encoding;
     // 集合包含的元素数量
     uint32_t length;
     // 保存元素的数组
     int8_t contents[];
}intset;
```
## 压缩列表 ziplist
压缩列表（ziplist）是Redis为了节省内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构，一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。
压缩列表的原理：压缩列表并不是对数据利用某种算法进行压缩，而是将数据按照一定规则编码在一块连续的内存区域，目的是节省内存。

# redis对象-基础数据的底层对应
redis中并没有直接使用以上所说的各种数据结构来实现键值数据库，而是基于一种对象，对象底层再间接的引用上文所说的具体的数据结构。
```
{
    // 数据结构: 字符串、hash、list、set、zset
    type;
    // 底层结构: SDS，链表，map，跳跃表，整数集合，压缩列表
    encoding;
    // 具体的数据结构的指针
    *ptr;
}
```
## 不同情况下的基础数据和底层数据的对应关系
字符串
1. int 数字的时候
2. raw 长字符串 大于39字节
3. embstr 短字符串 小于39字节

Ps ：embstr和raw都是由SDS动态字符串构成的。
唯一区别是：raw是分配内存的时候，redisobject和 sds 各分配一块内存，而embstr是redisobject和raw在一块儿内存中。

列表list
1. 压缩列表ziplist 列表对象的所有字符串元素长度都小于64字节 && 元素数量小于512
2. 双向链表 不满足ziplist的情况

hash
1. 压缩列表ziplist 列表对象的所有字符串元素长度都小于64字节 && 元素数量小于512
2. 哈希表 不满足ziplist的情况

set
1. 整数集合intset 所有元素都是整数 && 元素数量小于512
2. 哈希表 不满足intset的情况

zset
1. 压缩列表ziplist 列表对象的所有字符串元素长度都小于64字节 && 元素数量小于128
2. 跳表skiplist 不满足ziplist的情况
