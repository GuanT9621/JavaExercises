InnoDB 内存结构有四种： 缓冲池 更改缓冲区 自适应哈希索引 日志缓冲区

## Buffer Pool
参考 https://dev.mysql.com/doc/refman/5.7/en/innodb-buffer-pool.html
### 1 简介：
缓冲池在主内存，用来缓存表和索引数据。80% 的物理内存通常分配给缓冲池。 
缓冲池允许直接从内存中访问经常使用的数据，从而加快处理速度。
了解如何利用缓冲池将频繁访问的数据保存在内存中是 MySQL 调优的一个重要方面。
### 2 结构：
为了提高大容量读取操作的效率，缓冲池被划分为包含多行的页面。
为了缓存管理的效率，缓冲池被实现为页链表；
通过 LRU 算法的变体从缓存中淘汰数据。
页链表分为 年轻页链表 5/8 和 老年页链表 3/8 ；
### 3 更新逻辑：
列表的中点是新子列表的尾部与旧子列表的头部相交的边界。
当 InnoDB 将页面读入缓冲池时，它最初将其插入到中点（旧子列表的头部）。
由用户读取，第一次访问会立即发生，并且页面会变得年轻；由预读操作则不会。
### 4 优化：
问题：大量新数据将常用的数据推到老年页链表，甚至驱逐出缓冲池。
场景：
1 对 mysqldump 操作或没有 WHERE 子句的 SELECT 语句执行的表扫描可以将大量数据带入缓冲池并驱逐等量的旧数据，即使新数据不再使用。
2 类似地，由预读后台线程加载且仅访问一次的页面被移动到新列表的头部
解决：
1 使缓冲池扫描抗性 https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-midpoint_insertion.html
2 配置 InnoDB 缓冲池预取（预读）https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-read_ahead.html
### 5 缓冲池优化配置
* 将缓冲池的大小设置为尽可能大的值，从而为服务器上的其他进程留出足够的内存来运行而不会出现过多的分页。缓冲池越大， InnoDB 越像内存数据库，从磁盘读取一次数据，然后在后续读取期间从内存中访问数据。 参阅 14.8.3.1 节，“配置 InnoDB 缓冲池大小”。
* 在具有足够内存的 64 位系统上，您可以将缓冲池拆分为多个部分，以最大程度地减少并发操作之间的内存结构争用。 参阅 14.8.3.2 节，“配置多个缓冲池实例”。
* 将经常访问的数据保留在内存中，而不管操作的活动突然高峰会将大量不经常访问的数据带入缓冲池。 参阅 14.8.3.3 节，“使缓冲池扫描抗性”。
* 可以控制如何以及何时执行预读请求以异步将页面预取到缓冲池中，以预期很快需要这些页面。，参阅 14.8.3.4 节，“配置 InnoDB 缓冲池预取（预读）”。
* 可以控制何时发生后台刷新以及是否根据工作负载动态调整刷新速率。参阅 14.8.3.5 节，“配置缓冲池刷新”。
* 可以配置 InnoDB 如何保留当前缓冲池状态以避免服务器重新启动后的长时间预热。参阅 14.8.3.6 节，“保存和恢复缓冲池状态”。

## Change Buffer
### 简介
更改缓冲区是一种特殊的数据结构，当这些页面不在缓冲池中时，它会缓存对二级索引页面的更改。
可能由 INSERT、UPDATE 或 DELETE 操作 (DML) 导致的缓冲更改，稍后会在其他读取操作将页面加载到缓冲池中时合并。
1 问题：
为什么缓冲更改在读取操作时合并，而不是直接写入磁盘？
与聚集索引不同，二级索引通常是非唯一的，并且插入二级索引的顺序相对随机。类似地，删除和更新可能会影响索引树中不相邻的二级索引页面。
稍后合并缓存的更改，当受影响的页面被其他操作读入缓冲池时，避免了将二级索引页面从磁盘读入缓冲池所需的大量随机访问 I/O。
2 清除操作：
在系统大部分空闲或缓慢关闭期间，主线程运行的清洗操作会定期将更新的索引页写入磁盘。
与将每个值立即写入磁盘相比，清洗操作可以更有效地为一系列索引值写入磁盘块。
3 位置和类型：
在内存中，更改缓冲区占据了缓冲池的一部分。在磁盘上，更改缓冲区是系统表空间的一部分，其中索引更改在数据库服务器关闭时被缓冲。
缓存在更改缓冲区中的数据类型由 innodb_change_buffering 变量控制。默认 all
--all：     默认值。开启buffer inserts、delete-marking operations、purges
--none：    不开启change buffer
--inserts： 只是开启buffer insert操作
--deletes:  只是开delete-marking操作
--changes： 开启buffer insert操作和delete-marking操作
--purges：  对只是在后台执行的物理删除操作开启buffer功能

### 优化
如果索引包含降序索引列或主键包含降序索引列，则二级索引不支持更改缓冲。
因为 change buffer 可以减少磁盘读取和写入，所以更改缓冲对于 I/O 密集型工作负载最有价值；例如，具有大量 DML 操作（如批量插入）的应用程序受益于更改缓冲。
但是，change buffer 占用了 buffer pool 缓冲池的一部分，从而减少了可用于缓存数据页的内存。
如果工作集几乎适合缓冲池，或者如果您的表具有相对较少的二级索引，则禁用更改缓冲可能很有用。
如果工作数据集完全适合缓冲池，则更改缓冲不会带来额外开销，因为它仅适用于不在缓冲池中的页面。

### 配置
变量 innodb_change_buffer_max_size 
1 允许将更改缓冲区的最大尺寸配置为缓冲池总大小的百分比。（default 25，max 50）
2 这个变量是动态的，它允许在不重新启动服务器的情况下修改设置。
3 在具有大量插入、更新和删除活动的 MySQL 服务器上增加该变量，场景：更改缓冲区合并无法跟上新的更改缓冲区条目，导致更改缓冲区达到其最大大小限制。
4 在具有用于报告的静态数据的 MySQL 服务器上减小该变量，场景：更改缓冲区消耗了与缓冲池共享的过多内存空间，导致页面比预期更早地从缓冲池中老化。

## Adaptive Hash Index
自适应哈希索引使 InnoDB 能够在系统上执行更像内存数据库，具有适当的工作负载组合和足够的内存用于缓冲池，而不会牺牲事务功能或可靠性。
自适应哈希索引由 innodb_adaptive_hash_index 变量启用，或在服务器启动时由 --skip-innodb-adaptive-hash-index 关闭。

根据观察到的搜索模式，使用索引键的前缀构建哈希索引。前缀可以是任意长度，也可能只有B树中的一些值出现在哈希索引中。哈希索引是针对经常访问的索引页面的需求而构建的。
如果一个表几乎完全适合主内存，哈希索引通过启用任何元素的直接查找来加速查询，将索引值转换为一种指针。 InnoDB 有一个监控索引搜索的机制。如果 InnoDB 注意到查询可以从构建哈希索引中受益，它会自动这样做。

对于某些工作负载，哈希索引查找的加速大大超过了监控索引查找和维护哈希索引结构的额外工作。
在繁重的工作负载（例如多个并发连接）下，对自适应哈希索引的访问有时会成为争用的来源。使用 LIKE 运算符和 % 通配符的查询也往往不会受益。
对于不能从自适应哈希索引中受益的工作负载，关闭它可以减少不必要的性能开销。由于很难提前预测自适应哈希索引功能是否适合特定系统和工作负载，因此请考虑在启用和禁用它的情况下运行基准测试。

在 MySQL 5.7 中，自适应哈希索引功能是分区的。每个索引都绑定到一个特定的分区，每个分区都由一个单独的锁存器保护。
分区由 innodb_adaptive_hash_index_parts 变量控制。（default 8，max 512）
在早期版本中，自适应哈希索引功能受单个锁存器的保护，这可能成为繁重工作负载下的竞争点。 

您可以在 SHOW ENGINE INNODB STATUS 输出的 SEMAPHORES 部分监视自适应哈希索引的使用和争用。
如果有大量线程等待 btr0sea.c 中创建的 rw-latch，请考虑增加自适应哈希索引分区的数量或禁用自适应哈希索引。

### 区别
有关哈希索引的性能特征的信息，参 https://dev.mysql.com/doc/refman/5.7/en/index-btree-hash.html
* B+树索引可用于使用 =、>、>=、<、<= 或 BETWEEN 运算符的表达式中的列比较。如果 LIKE 的参数是不以通配符开头的常量字符串，则索引也可用于 LIKE 比较。
* 哈希索引仅用于使用 =、!=、IN 运算符的相等比较。它们不用于查找值范围的比较运算符，例如 <。
  * 优化器不能使用哈希索引来加速 ORDER BY 操作。 
  * MySQL 无法确定两个值之间大约有多少行（范围优化器使用它来决定使用哪个索引）。
  * 只能使用整个键来搜索行。 （使用 B 树索引，键的任何最左边的前缀都可用于查找行。）

## Log Buffer
日志缓冲区是保存要写入磁盘上日志文件的数据的内存区域。
innodb_log_buffer_size 变量定义日志缓冲区大小。（ default 16MB） 日志缓冲区的内容会定期刷新到磁盘。
innodb_flush_log_at_trx_commit 变量控制日志缓冲区的内容如何写入和刷新到磁盘。
innodb_flush_log_at_timeout 变量控制日志刷新频率。

### 优化
大型日志缓冲区使大型事务能够运行，而无需在事务提交之前将重做日志数据写入磁盘。因此，如果您有更新、插入或删除许多行的事务，则增加日志缓冲区的大小可以节省磁盘 I/O。



