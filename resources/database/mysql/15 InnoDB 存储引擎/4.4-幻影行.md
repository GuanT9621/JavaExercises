# 幻影行
## 现象
当同一个查询在不同的时间产生不同的行集时，事务中就会出现所谓的幻象问题。例如，如果 SELECT 执行了两次，但第二次返回了第一次没有返回的行，则该行是“幻像”行。

## 例子
假设子表的 id 列上有一个索引，并且您想要读取并锁定表中标识符值大于 100 的所有行，以便稍后更新所选行中的某些列：
``` 
SELECT * FROM child WHERE id > 100 FOR UPDATE; 
```
查询从 id 大于 100 的第一条记录开始扫描索引。让表包含 id 值为 90 和 102 的行。
如果在扫描范围内的索引记录上设置的锁不锁定在间隔（在本例中，间隔为 90 和 102），另一个会话可以将新行插入 id 为 101 的表中。
如果您要在同一个事务中执行相同的 SELECT，您会看到一个新行查询返回的结果集中的 id 为 101（“幻像”）。
如果我们将一组行视为一个数据项，那么新的幻像子将违反一个事务应该能够运行的事务的隔离原则，即使其读取的数据在事务期间不会发生变化。

## 解法 Next-Key Lock
为了防止幻象，InnoDB 使用了一种称为 next-key 锁定的算法，该算法将 index-record lock 与 index gap lock 相结合。 
InnoDB 执行行级锁定的方式是，当它搜索或扫描表索引时，它会在它遇到的索引记录上设置共享或排他锁。因此，行级锁实际上是索引记录锁。
此外， 索引记录上的next-key lock也会影响索引记录之前的“间隙”。也就是说，next-key 锁是索引记录锁加上索引记录前面的间隙上的间隙锁。
如果一个会话在索引中的记录 R 上具有共享或排他锁，则另一个会话不能在索引顺序中 R 之前的间隙中插入新的索引记录。

InnoDB 在扫描索引时，还可以锁定索引中最后一条记录之后的间隙。
在前面的例子中就是这样：为了防止任何插入到 id 大于 100 的表中，InnoDB 设置的锁包括在 id 值 102 之后的间隙上的锁。

## 用途
您可以使用 next-key lock 在您的应用程序中实现唯一性检查：
如果您在共享模式下读取数据并且没有看到要插入的行的重复项，那么您可以安全地插入您的行并知道在读取期间在您的行的后继上设置的 next-key lock 可防止任何人同时为您的行插入重复项。
因此，next-key lock 使您能够“锁定”表中不存在的东西。

可以禁用间隙锁定。这可能会导致幻像问题，因为当间隙锁定被禁用时，其他会话可以将新行插入到间隙中。
