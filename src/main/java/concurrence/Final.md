# final关键字
可以用来修饰引用、方法和类。

## 修饰一个引用
1. 如果引用为基本数据类型，则该引用为常量，该值无法修改；
2. 如果引用为引用数据类型，比如对象、数组，则该对象、数组本身可以修改，但指向该对象或数组的地址的引用不能修改。
3. 如果引用时类的成员变量，则必须当场赋值，否则编译会报错。

## 用来修饰一个方法
当使用final修饰方法时，这个方法将成为最终方法，无法被子类重写。但是，该方法仍然可以被继承。

## 用来修饰类
当用final修改类时，该类成为最终类，无法被继承。简称为“断子绝孙类”。

## 实现原理
对于final域，编译器和CPU会遵循两个排序规则：
1. 新建对象过程中，构造体中对final域的初始化写入和这个对象赋值给其他引用变量，这两个操作不能重排序；（废话嘛）
2. 初次读包含final域的对象引用和读取这个final域，这两个操作不能重排序；（晦涩，意思就是先赋值引用，再调用final值）

总之上面规则的意思可以这样理解，必需保证一个对象的所有final域被写入完毕后才能引用和读取。  
这也是内存屏障的起的作用：
1. 写final域：在编译器写final域完毕，构造体结束之前，会插入一个StoreStore屏障，保证前面的对final写入对其他线程/CPU可见，并阻止重排序。
2. 读final域：在上述规则2中，两步操作不能重排序的机理就是在读final域前插入了LoadLoad屏障。X86处理器中，由于CPU不会对写-写操作进行重排序，
所以StoreStore屏障会被省略；而X86也不会对逻辑上有先后依赖关系的操作进行重排序，所以LoadLoad也会变省略。
