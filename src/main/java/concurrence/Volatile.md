# volatile
volatile是轻量级的 synchronized，他在多处理器开发中保证了共享变量的可见性。  
可见性的意思是当一个线程修改一个共享变量是，另一个线程能读到这个修改的值。  

### 汇编里的 lock 
volatile修饰的共享变量进行写操作时，会多出第二行汇编代码 lock addl $0x0，而lock前缀指令会：   
1 将当前处理器缓存行的数据写回系统内存  
2 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。参考缓存一致性协议  
LOCK# 信号以前锁总线，现在锁缓存，毕竟锁总线消耗太大。  

*优化实例：*  
Doug lea追加对象到64字节的方式来填满高速缓冲区的缓存行，避免头节点和尾节点加载到同一个缓存行，  
两者修改时不会互相锁定。注意只在处理器L1 L2 L3缓存的高速缓存行是64个字节宽，不支持部分填充缓存行时。
参考 java.util.concurrent.LinkedTransferQueue.LinkedTransferQueueTest

### 缓存一致性协议
每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了。