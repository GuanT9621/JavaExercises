> https://blog.csdn.net/han_zhuang/article/details/106103260

## 判断对象是否可以被回收
1、引用计数计数法
内容：在对象中添加一个引用计数器，每当有一个地方引用它，计数器就加一；当引用失效时，计数器就减一；任何时刻计数器为零的对象都是不可能在被使用的
缺点：无法解决对象之间的循环引用问题。如下图所示对象A和对象B，他们之间相互引用，除此之外再无任何引用，则他们的引用计数器值都为1，但实际上这两个对象都不可能在被访问了，而且无法被回收

2、可达性分析算法
内容：通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始根据引用关系向下搜索，搜索过程所走的路径称为“引用链”（Reference Chain），
如果某个对象到GC Roots之间没有任何的引用链相连（或者用图论的话来说就是从GC Root到这个对象不可达），则证明这个对象是不可能再被使用的
Java虚拟机中的垃圾回收器采用的可达性分析算法探索所有存活对象


## Java中的四种引用
强引用：
无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象
类似Object obj = new Object()

软引用：
仅有软引用引用该对象时，在垃圾回收之后，如果内存仍然不足时再次触发垃圾回收，回收软引用对象
通过SoftReference类来实现软引用
可以配合引用队列来释放软引用自身

弱引用：
仅有弱引用引用该对象时，在垃圾回收时，无论内存是否够用都会回收弱引用对象
通过WeakReference类来实现弱引用
可以配合引用队列来释放弱引用自身

虚引用：
一个对象是否存在虚引用，不会对其生存时间产生印象，也无法通过虚引用来取得一个对象实例，设置虚引用的唯一目的是为了能在这个对象被收集器回收时收到一个系统通知
通过PhantomReference类来实现弱引用
必须配合引用队列使用，通常配合ByteBuffer使用，被引用对象回收时，会将虚引用入队，由ReferenceHandler线程调用虚引用的相关方法释放直接内存

终结引用（FinalReference）：
无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由Finalizer线程通过终结器引用找到被引用对象并调用其finalize方法，第二次GC才能回收被引用对象。
但是Finalizer线程的优先级非常低，不要在finalize方法中进行资源释放等操作（可以使用try-finally代替）。

## 收集器
1. 新生代收集器：Serial、  ParNew、     Parallel Scavenge
2. 老年代收集器：CMS、     Serial Old、 Parallel Old
3. 整堆收集器：  G1

## 概念
1. 并行收集：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。
2. 并发收集：指用户线程与垃圾收集线程同时工作（不一定是并行的可能会交替执行）。用户程序在继续运行，而垃圾收集程序运行在另一个CPU上。
3. 吞吐量：即CPU用于运行用户代码的时间与CPU总消耗时间的比值（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )）。
   例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%

## 收集算法
常用算法：1.标记-清除算法、2.标记-整理算法、3.标记-复制算法 4.分代收集算法。

**标记-清除算法（Mark Sweep）**
内容：首先根据对象到GC Roots之间是否有可达路径来标记需要回收的对象，再根据标记的结果对内存进行清除（将清除的内存的起始地址放入可分配内存表中）
优点：速度快，简单
缺点：
内存空间碎片化：标记清除算法会产生大量不连续的内存碎片，可能会导致之后给较大对象分配内存时，虽然总内存数量足够，但是没有足够的连续内存而导致GC
执行效率不稳定：标记和清除两个过程的执行效率都随对象的数量增长而降低

**标记-整理算法（Mark Compact）**
内容：首先根据对象到GC Roots之间是否有可达路径来标记需要回收的对象，之后让所有存活的对象都向内存空间的一端移动，然后清理掉边界以外的内存。
优点：不会出现内存碎片化的问题
缺点：垃圾回收效率没有标记清除高，因为需要移动存活对象，还要更新对存活对象引用（一般需要全部暂停用户应用程序才能进行）

**标记-复制算法（Mark Copy）**
内容：它将内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块内存用完了，就将还存活的对象复制到另外一块，然后把已使用过的内存空间一次清理掉
优点：标记-复制算法优点也是不会产生内存碎片化的问题，分配内存时只需要移动堆顶指针按顺序分配即可
缺点：它的缺点也十分明显，就是可用内存缩小到了原来的一半

**分代垃圾回收算法**
分代收集理论的理论基础：
弱分代理论（Weak Generational Hypothesis）：绝大数对象都是朝生夕灭的
强分代理论（Strong Generational Hypothesis）：熬过越多次垃圾回收的对象就越难以消亡
跨代引用假说（International Reference Hypothesis）：跨代引用相对于同代引用仅占极少数

分代：
新生代（Eden/Young）：新的对象都在新生代内存区域中分配
幸存区 To/From（Survivor To/From）：对新生代和幸存区 From进行GC后，将新生代和幸存区 From中存活的对象复制到幸存区 To，然后幸存区 To和幸存区 From进行区域交换（Appel式回收：新生代/幸存区=8/1）
老年代（Old/Tenured）：用于存放在新生代和幸存区经过多次GC（最大15次）没有被回收而晋升的对象

GC分类：
部分收集（Partial GC）：只对Java堆中的一部分进行的垃圾收集
新生代收集（Minor GC/Young GC）：针对新生代（还有幸存区）的垃圾收集
老年代收集（Major GC/Old GC）：针对老年代的垃圾收集，只有CMS收集器有该行为
混合收集（Mixed GC）：针对整个新生代和部分老年代的垃圾收集，只有G1收集器有该行为
整堆回收（Full GC）：收集整个Java堆和方法区的垃圾回收（相比Minor GC非常慢，尽量不要触发）

分代流程：
    1. 对象首先分配在新生代（Eden）
    2. 新生代空间不足时触发Minor GC，新生代和幸存区 From中存活的对象复制到幸存区 To，存活对象的年龄加1并交换From和To区域
    3. Minor GC采用标记-复制算法，复制过程由于改变的对象在内存中的位置，为了防止对象访问发生错乱需要进行Stop The World，也就是停止所有用户应用线程，等垃圾回收结束用户现场才恢复运行
    4. 当对象的寿命（GC之后存活的次数）超过阙值时，会晋升到老年代，最大寿命15（4bit）
    5. 大对象分配时，一般直接分配到老年区
    6. 当老年代的空间也发生不足时，会先触发Minor GC，如果空间仍然不足，那么出发Full GC（STW的时间更长）

## 默认收集器
jdk1.7 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）
jdk1.8 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）
jdk1.9 默认垃圾收集器G1
-XX:+PrintCommandLineFlagsjvm参数可查看默认设置收集器类型
-XX:+PrintGCDetails亦可通过打印的GC日志的新生代、老年代名称判断

# 一：Serial 收集器
Serial收集器是最基本的、发展历史最悠久的收集器。
特点：单线程、简单高效（与其他收集器的单线程相比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。
    收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）。
应用场景：适用于Client模式下的虚拟机。

# 二：ParNew收集器
ParNew收集器其实就是Serial收集器的多线程版本。
除了使用多线程外其余行为均和Serial收集器一模一样（参数控制、收集算法、Stop The World、对象分配规则、回收策略等）。
特点：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。
    和Serial收集器一样存在Stop The World问题
应用场景：ParNew收集器是许多运行在Server模式下的虚拟机中首选的新生代收集器，因为它是除了Serial收集器外，唯一一个能与CMS收集器配合工作的。

# 三：Parallel Scavenge 收集器
与吞吐量关系密切，故也称为吞吐量优先收集器。
特点：属于新生代收集器也是采用复制算法的收集器，又是并行的多线程收集器（与ParNew收集器类似）。
    该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：GC自适应调节策略（与ParNew收集器最重要的一个区别）
    GC自适应调节策略：Parallel Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。
    当开关打开时不需要手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。
Parallel Scavenge收集器使用两个参数控制吞吐量：
    XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间
    XX:GCRatio 直接设置吞吐量的大小。

# 四：Serial Old 收集器
Serial Old是Serial收集器的老年代版本。
特点：同样是单线程收集器，采用标记-整理算法。
应用场景：主要也是使用在Client模式下的虚拟机中。也可在Server模式下使用。
Server模式下主要的两大用途：
    在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用。
    作为CMS收集器的后备方案，在并发收集Concurent Mode Failure时使用。

# 五：Parallel Old 收集器
是Parallel Scavenge收集器的老年代版本。
特点：多线程，采用标记-整理算法。
应用场景：注重高吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge+Parallel Old 收集器。

# 六：CMS收集器
一种以获取最短回收停顿时间为目标的收集器。
特点：基于标记-清除算法实现。并发收集、低停顿。
应用场景：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务。
CMS收集器的运行过程分为下列4步：
初始标记：标记GC Roots能直接到的对象。速度很快但是仍存在Stop The World问题。
并发标记：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行。
重新标记：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题。
并发清除：对标记的对象进行清除回收。
CMS收集器的内存回收过程是与用户线程一起并发执行的。

CMS收集器的缺点：
对CPU资源非常敏感。
无法处理浮动垃圾，可能出现Concurrent Model Failure失败而导致另一次Full GC的产生。
因为采用标记-清除算法所以会存在空间碎片的问题，导致大对象无法分配空间，不得不提前触发一次Full GC。

# 七：G1收集器
一款面向服务端应用的垃圾收集器。
特点如下：
并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿时间。部分收集器原本需要停顿Java线程来执行GC动作，G1收集器仍然可以通过并发的方式让Java程序继续运行。
分代收集：G1能够独自管理整个Java堆，并且采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。
空间整合：G1运作期间不会产生空间碎片，收集后能提供规整的可用内存。
可预测的停顿：G1除了追求低停顿外，还能建立可预测的停顿时间模型。能让使用者明确指定在一个长度为M毫秒的时间段内，消耗在垃圾收集上的时间不得超过N毫秒。

G1为什么能建立可预测的停顿时间模型？
因为它有计划的避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。这样就保证了在有限的时间内可以获取尽可能高的收集效率。

G1与其他收集器的区别：
其他收集器的工作范围是整个新生代或者老年代、G1收集器的工作范围是整个Java堆。在使用G1收集器时，它将整个Java堆划分为多个大小相等的独立区域（Region）。虽然也保留了新生代、老年代的概念，但新生代和老年代不再是相互隔离的，他们都是一部分Region（不需要连续）的集合。

G1收集器存在的问题：
Region不可能是孤立的，分配在Region中的对象可以与Java堆中的任意对象发生引用关系。在采用可达性分析算法来判断对象是否存活时，得扫描整个Java堆才能保证准确性。其他收集器也存在这种问题（G1更加突出而已）。会导致Minor GC效率下降。

G1收集器是如何解决上述问题的？
采用Remembered Set来避免整堆扫描。G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用对象是否处于多个Region中（即检查老年代中是否引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆进行扫描也不会有遗漏。
如果不计算维护 Remembered Set 的操作，G1收集器大致可分为如下步骤：

初始标记：仅标记GC Roots能直接到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象。（需要线程停顿，但耗时很短。）

并发标记：从GC Roots开始对堆中对象进行可达性分析，找出存活对象。（耗时较长，但可与用户程序并发执行）

最终标记：为了修正在并发标记期间因用户程序执行而导致标记产生变化的那一部分标记记录。且对象的变化记录在线程Remembered Set  Logs里面，把Remembered Set  Logs里面的数据合并到Remembered Set中。（需要线程停顿，但可并行执行。）

筛选回收：对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。（可并发执行）