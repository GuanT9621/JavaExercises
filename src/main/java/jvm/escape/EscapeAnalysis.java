package jvm.escape;

/**
 * 逃逸分析 是什么？
 * 在《深入理解Java虚拟机中》关于Java堆内存有这样一段描述：
 * "但是，随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。"
 *
 * 在编译程序优化理论中，逃逸分析是一种确定指针动态范围的方法——分析在程序的哪些地方可以访问到指针。它涉及到指针分析和形状分析。
 *
 *
 * 编译器可以使用逃逸分析的结果作为优化的基础：
 *      将堆分配转化为栈分配。如果某个对象在子程序中被分配，并且指向该对象的指针永远不会逃逸，该对象就可以在分配在栈上，而不是在堆上。在有垃圾收集的语言中，这种优化可以降低垃圾收集器运行的频率。
 *      同步消除。如果发现某个对象只能从一个线程可访问，那么在这个对象上的操作可以不需要同步。
 *      分离对象或标量替换。如果某个对象的访问方式不要求该对象是一个连续的内存结构，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。
 */
public class EscapeAnalysis {

    /**
     * 在这个示例中，创建了两个对象(用alloc注释)，其中一个作为方法的参数。
     * 方法setFoo()接收到foo参数后，保存Foo对象的引用。如果Bar对象保存在堆中，那么Foo的引用将逃逸。
     *
     * 但在这种情况下，编译器可以使用逃逸分析确定Bar对象本身并没有逃逸example()的调用。
     * 这意味着Foo引用无法逃逸。因此，编译器可以安全地在栈上分配两个对象。
     */
    public static void main(String[] args) {
        example();
    }

    public static void example() {
        Foo foo = new Foo(); // alloc
        Bar bar = new Bar(); // alloc
        bar.setFoo(foo);
    }

}
