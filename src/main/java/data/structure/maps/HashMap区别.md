# HashMap
线程不安全
resize  线程不安全
read    线程不安全
write   线程不安全，出现覆盖

## 1.7
底层数据结构是数组加链表
变化：
1. hash是可变的，因为有rehash的操作
2. table是直接赋值给了一个空数组，在第一次put元素时初始化和计算容量。
3. table是单独定义的inflateTable（）初始化方法创建的。
4. 扩容方法 transfer ，采用头插法将旧数组的元素转移到新的数组。不扩容时，正常插入元素(createEntry方法)，也是头插法。

## 1.8
底层数据结构是数组 + 链表（6）+ 红黑树（8）
变化：
1. hash是final修饰，也就是说hash值一旦确定，就不会再重新计算hash值了
2. table没有赋值，属于懒加载，构造方式时已经计算好了新的容量位置（大于等于给定容量的最小2的次幂
3. table是resize（）方法创建的。
4. 树化的两个条件，单条桶长度大于等于8，桶总数大于等于64才发生
5. 扩容方法 尾插法，解决多线程的链表死循环问题
6. 初始化时,添加节点结束之后和判断树化的时候都会去判断扩容，通过e.hash & oldCap==0来判断新插入的位置是否为原位置。

| 比较       | HashMap1.7	            | HashMap1.8          |
|----------|------------------------|---------------------|
| 数据结构     | 	数组+链表                 | 	数组+链表+红黑树          |
| 节点       | Entry                  | 	Node TreeNode      |
| Hash算法	  | 较为复杂	                  | 异或hash右移16位         |
| 对Null的处理 | 	单独写一个putForNull()方法处理 | 作为以一个Hash值为0的普通节点处理 |
| 初始化	     | 赋值给一个空数组，put时初始化	      | 没有赋值，懒加载，put时初始化    |
| 扩容	      | 插入前扩容	                 | 插入后，初始化，树化时扩容       |
| 节点插入     | 	头插法                   | 尾插法                 |



