package algorithm.gametheory;

/**
 * https://blog.csdn.net/qunqunstyle99/article/details/80954752
 *
 * 有2个鸡蛋，从100层楼上往下扔，以此来测试鸡蛋的硬度。比如鸡蛋在第9层没有摔碎，在第10层摔碎了，那么鸡蛋不会摔碎的临界点就是9层。
 * 问：如何用最少的尝试次数，测试出鸡蛋不会摔碎的临界点？
 *
 * 方法一 从第1层到100层一个一个试。 最好情况 1，最坏情况 100。
 * 方法二 二分法，从中间试。        最好情况 6，最坏情况 1 + 50 = 51。
 * 方法三 每10层扔。               最好情况 1 + 9 = 10，最坏情况 10 + 9 = 19。
 *
 * 如何让第一枚鸡蛋和第二枚鸡蛋的尝试次数尽可能均衡呢？
 *      （可以理解成在第一枚蛋查找的范围尽可能的大和第二枚蛋查找的范围尽可能的小之间的一个平衡。）
 *       可能会有人说这俩事是矛盾的，确实，就是这样，但是我们可以在两者之间找到一个平衡点。
 *
 * 思路一 ：假设存在最优解，也就是最少的尝试次数是x次，那么最好情况是 1 + (x-1) = x
 *          那么下一次的鸡蛋应该扔在什么地方呢？
 *          如果第一次的蛋没有牺牲，我们的尝试次数就少了一次，同时我们也刷掉了X个错误的楼层。
 *          这时候问题就转化为了：我们有两个鸡蛋，在 100-x 层楼往下扔，要求尝试次数不超过 x-1 次(因为我们已经仍过 1 次了)。
 *          （注意理解第一次范围尽可能大，第二次尽可能小的概念）
 *          所以下一次在 x-1 层。 那么最好情况是 1 + (x-1 - 1) = x-1
 *          可得 x + (x-1) + ~ + 1 = 100 即 (x+1)x/2 = 100 那么 x = 14.2
 *
 * 思路二 ：假设存在最优解，也就是最少的尝试次数是x次，那么最好情况是 1 + (x-1) = x
 *          那么下一次再扔时还要维持 x 的话，则 2 + (x - 2) = x
 *          推理可得 x + (x - x) = x
 *          然后，我们可以发现在 a + (x - a) = x 中， (x - a)是每次的真实层数。
 *          则 (x-1) + (x-2) + ~ + 1 + 0 = 100 即 (x-1)x/2 = 100 那么 x = 14.7
 */
public class Egg {
}
