package thread.pool;

/**
 * 多线程调度：每个线程可能会有自己的优先级，但是优先及并不意味着高优先级的线程一定会被调度，而是由cup随机的选择
 *      抢占式：一个线程在执行自己的任务时，虽然任务还没有执行完，但是cpu会迫使它暂停，让其它线程占有cpu的使用权。
 *      协作式：一个线程在执行自己的任务时，不允许被中途打断，一定等当前线程将任务执行完毕后才会释放对cpu的占有，其它线程才可以抢占该cpu
 *
 * 比较：
 *      抢占式线程调度不易发生饥饿现象，不易因为一个线程的问题而影响整个进程的执行，但是其频繁阻塞与调度，会造成系统资源的浪费。
 *      协作式的线程调度很容易因为一个线程的问题导致整个进程中其它线程饥饿
 *
 * jvm 角度
 *      在JVM层面上，我们的线程都是由JVM负责调度与打断的，当某个线程的时间片用完了，JVM就会剥夺其对CPU的使用权，交给另一个线程使用
 *
 * 多线程并发运行的角度
 *      一个线程调用另一个线程的interrupt() 方法中断线程，并不是强行关闭这个线程，只是跟这个线程打个招呼，将线程的中断标志位置为true。
 *      线程是否中断，由线程本身决定，线程本身可以判断 “中断标志位”，如果是 true 当前线程可以在代码层面上停止当前线程的执行逻辑。
 *      这里就充分的体现了线程协作的思想，“你不能强行中断我，只要我主动放弃你才能占有我的cpu”。
 *
 * 总结：
 *      1.Java在调度机制上采用的是抢占式的线程调度机制。
 *      2.Java线程在运行的过程中多个线程之间式协作式的。
 *
 */
public class DispatchPoolTest {

}
