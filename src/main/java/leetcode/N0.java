package leetcode;

/**
 * 思路总结
 *
 * 双指针
 * 双指针卡尺
 * 滑动窗口
 * 栈的活用                                  例如 S_Calc
 * 单调栈
 * 双栈法
 * 递归（几乎所有的树，都需要递归）
 * 回溯算法 = 深度优先搜索 -> 递归(例如全排列)
 * DFS Deep First Search 深度优先搜索         例如 N655_m
 * BFS Breath First Search 广度优先搜索       例如 S_PrintTree
 * 动态规划：动态规划转移方程，边界条件                  例如 N64 N198
 * 自动机                                      例如 N8
 * 前缀树                                      例如 N208
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
public class N0 { }
/**
 * 时间复杂度：如果一个算法的执行次数是 T(n)，那么只保留最高次项，同时忽略最高项的系数后得到函数 f(n)，此时算法的时间复杂度就是 O(f(n))
 */
