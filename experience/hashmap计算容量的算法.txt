算法如下：
```
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```
tableSizeFor的功能（不考虑大于最大容量的情况）是返回大于输入参数且最近的2的整数次幂的数。比如10，则返回16。

(1) int n = cap - 1;
再赋值给 n 的目的是另找到的目标值大于或等于原值。
例如二进制1000，十进制数值为8。如果不对它减1而直接操作，将得到答案10000，即16。显然不是结果。
减1后二进制为111，再进行操作则会得到原来的数值1000，即8。

(2) n |= n >>> 1 执行顺序
先执行 n >>> 1 得到 m, 再执行 n = n | m;

(3) 为什么要 n |= n >>> 1, 2, 4, 8, 16
为了让最高位的 1 后面的位全变为1。最后再加一，即变成了 10...0，即得到了2的整数次幂的值了。

HashMap 里的 MAXIMUM_CAPACITY 是 2^30, 结合tableSizeFor()的实现，猜测设置原因如下：
int 的正数最大可达2^31 - 1，而没办法取到 2^31。所以容量也无法达到2^31。又需要让容量满足2的幂次。所以设置为2^30。

Note: java中有三种移位运算符
<<      左移运算符，num << 1, 相当于num乘以2
>>      右移运算符，num >> 1, 相当于num除以2
>>>     无符号右移，忽略符号位, 空位都以0补齐
